= Create WebSocket Servers with Spring WebSocketServer
Mario Gray <mgray@pivotal.io>
:Author Initials: MVG
:toc:
:icons:
:numbered:
:imagesdir: ./graphics
:website: https://docs.spring.io/spring/docs/5.0.0.BUILD-SNAPSHOT/spring-framework-reference/html/web-reactive.html
:note: Drain the [BAYEUX]

== This Demo
This demo will stand up Spring application service that exposes a reactive WebSocket service through the Spring 5's WebSockets API.
Typically, we will use a more traditional messaging system to deliver and expect events between services. Using messaging brokers such as Kafka, RabbitMq, AWS/SQS, Kinesis all enable our services to deliver real-time/mixed-time events to internal services that require them. Its not good enough to introduce the broker model to our application deployed to the public - because the underlaying transport or even service may change under the app's (feet). Thus WebSockets give us a standards and performant approach to delivering realtime events to our apps.

A sample graph of services and then of a mix of clients that connect

== WebSocket Server
Spring's WebSocket API is new in Spring 5, and enables reactive event and connection handling. We will introduce a single WebSocket handler, and show whats needed to get started using Spring's `WebSocketServer` support.
You'll want to start a new Spring project using start.spring.io[this link] to autogenerate a maven based POM.  If you go with a different approach, just make sure to 
have `webflux`, and `lombok` projects.

First, wire in a `WebSocketHandlerAdapter` to handle our web socket handshake, upgrade, and other connection details.

.socket_handler_adapter
[source,java]
----
    @Bean
    WebSocketHandlerAdapter socketHandlerAdapter() {
        return new WebSocketHandlerAdapter();
    }
----

To get started, we will need a method for handling a websocket session. The simplest way to do this is to create a `WebSocketHandler` instance 
that calls `session.send` with our custom stream logic. For this handler, on each session we will stream 100 integers and append bang '!' for primes.
Using `Flux.interval` and `zipWith` in combination allows us to ensure a steady frequency of events.


.socket_session_handler
[source,java]
----
    WebSocketHandler webSocketHandler() {
        return session ->
                session.send(
                        Flux.interval(Duration.ofSeconds(1))
                                .zipWith(
                                        Flux.fromStream(Stream.iterate(0, i -> i + 1).limit(100))
                                        , (x, y) -> y + (is_prime(y) ? "!" : ""))
                                .map(session::textMessage)
                ).and(
                        session.receive()
                                .map(WebSocketMessage::getPayloadAsText)
                                .doOnSubscribe(sub -> log.info("socket session started"))
                                .doFinally(sig -> {
                                    log.info("session complete:" + sig.toString());
                                    session.close();
                                })
                );
    }
// bruteforced search :p
    boolean is_prime(long num) {
        if (num <= 1) return false;
        if (num % 2 == 0 && num > 2) return false;
        for (int i = 3; i < num / 2; i += 2) {
            if (num % i == 0)
                return false;
        }
        return true;
    }    
----

Using `and` operator lets us join this session with a `receive()` flow that reacts to incoming messages. In this case, we dont have any need for it, but it's good to illustrate this side of functionality for the curious.
Our session makes use of the `doOn...` signal handlers used to respond to connection lifecycle events. Always make sure to call `session.close()` or else you end up with leaks.

Finally, to map URI's to our handler we wire in a reactive `SimpleUrlHandlerMapping` to delegate socket connections on URL `/ws/feed`.

.uri_handler_mapping
[source,java]
----
    @Bean
    HandlerMapping simpleUrlHandlerMapping() {
        SimpleUrlHandlerMapping simpleUrlHandlerMapping = new SimpleUrlHandlerMapping();
        RequestMappingHandlerMapping foo = new RequestMappingHandlerMapping();
        simpleUrlHandlerMapping.setUrlMap(Collections.singletonMap("/ws/feed",
                webSocketHandler()));
        simpleUrlHandlerMapping.setOrder(10);
        return simpleUrlHandlerMapping;
    }
----

Finally, we will execute this server app:

.server_app_main
[source,java]
----
    public static void main(String[] args) {
        SpringApplication.run(WebSocketConfiguration.class, args);
    }
----

Start the application:

[source,bash]
----
$ mvn clean spring-boot:run
...
2018-04-26 15:36:54.330  INFO 10671 --- [           main] o.s.b.web.embedded.netty.NettyWebServer  : Netty started on port(s): 8080
----

Now we are ready to implement the client, and demonstrate the new server we just stood up!

== References/Readling List

* Spring WebFlux guide
** https://docs.spring.io/spring/docs/5.0.0.BUILD-SNAPSHOT/spring-framework-reference/html/web-reactive.html
** https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html

* Articles
** https://ordina-jworks.github.io/reactive/2016/12/12/Reactive-Programming-Spring-Reactor.html

* W3C Proposals
** https://tools.ietf.org/html/rfc6455

* Theory
** http://reactivex.io/documentation/operators.html
** https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/debounce.md


