= Streaming events to your clients via Spring WebSockets
Mario Gray <mgray@pivotal.io>
:Author Initials: MVG
:toc:
:icons:
:numbered:
:imagesdir: ./graphics
:website: https://docs.spring.io/spring/docs/5.0.0.BUILD-SNAPSHOT/spring-framework-reference/html/web-reactive.html

== Purpose
Web-socket event streaming is one of those concers we talk about when consumer needs that exist at the edge 
of our service matrix. Typically, we will use a more traditional messaging system to deliver and expect
events within our service cloud. Using applications such as Kafka, RabbitMq, AWS/SQS, Kinesis all enable
our services to deliver real-time/mixed-time events to services that require them.

[A sample graph of service matrixes (clouds) and then of a mix of clients that 
connect]

When we need to connect to a variety of messaing consumer/producers then it may be well it's worth
to decide on an well-implemented standard that for example the IETF has decided upon - https://tools.ietf.org/html/rfc6455[RFC 6455].
In it's place we find another option - long-polling[https://tools.ietf.org/html/rfc6202], which is decidedly not realtime
nor resource-sipping (many HTTP connects mean more clients are initiating requests). The importance of both is that
necessity as Carriers - physical layer 1 via OSI model -  must make sweeping policy changes to allow the former. Thus,
in order to gain the advantages of a realtime application-layer 6 connection, long-polling fit the bill until all edge carriers 
could support websockets.

This article we will talk about standing up a Spring application service that exposes websockets,
consumes websockets, and allows fo long-polling degredation. Lets take a look at the configuration in 
this next section:

== Reactive WebSocket - Not Imparative!
