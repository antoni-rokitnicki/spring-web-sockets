= Streaming events to your clients via Spring WebSockets
Mario Gray <mgray@pivotal.io>
:Author Initials: MVG
:toc:
:icons:
:numbered:
:imagesdir: ./graphics
:website: https://docs.spring.io/spring/docs/5.0.0.BUILD-SNAPSHOT/spring-framework-reference/html/web-reactive.html
:note: Drain the [BAYEUX]

== Purpose
This article we will talk about standing up a Spring application service that exposes reactive WebSocket service and client through the Spring WebFlux API.
Typically, we will use a more traditional messaging system to deliver and expect events between services. Using messaging brokers such as Kafka, RabbitMq, AWS/SQS, Kinesis all enable our services to deliver real-time/mixed-time events to internal services that require them. Its not good enough to introduce the broker model to our application deployed on field - because the underlaying transport or even service may change under the app's (feet). Thus WebSockets give us a standards and performant approach to delivering events to our apps.

[A sample graph of services and then of a mix of clients that connect]

== Whats in a socket?
Lets look at the prior and current methods to delivering events that span about the past 10 years (not including comet-d).

.Short Polling
Short-polling as it's called, the client repeats a request for new events in a stream, while the server vends a single or series of events that happened since the last request. This works when very little data is traveling in either direction, and where the interval can be kept sparse. For example, a news feed may update just once every half minute which is fine for consumers. However this will breakdown once new information must be delivered as soon as possible in which case the interval must be tightned, causing additional contention at the edge.

.Long Polling
This gets us into long-polling[https://tools.ietf.org/html/rfc6202], which has been the happy medium between near-real-time delivery and persistent sockets (ws). A long-polling client intiates a request that can be satisfied by either a timeout, connection status change, or the reception of new event(s). The reason for the timeout exists as an exercise for https://tools.ietf.org/html/rfc6202[this IETF recommendation] as most intermediate HTTP proxies police HTTP connections, causing timeouts sooner than expected. Therefore, the IETF recommends somewhere between 30 and 120 second timeout tolerances. 
The downside to long-polling is that the client may end up making many requests (like traditional polling) as events begin accumulating on the server for the client to request.

.Web Socket
Finally, the https://tools.ietf.org/html/rfc6455[WebSocket protocol] eliminates the need for polling. The websocket is really just a standard bi-directional TCP connection, that began life as a HTTP request. The details of this connection negotiation are outlined in the [RFC] as well.
WebSockets really shine when you have many application events that need to be delivered in high-frequency, as soon as possible. Real-time applications like stock tickers(this demo), chat apps, and even audio/video apps - WebSockets handles binary content too!

== Enter the WebFlux
Spring WebFlux is a complete reimplementation of the MVC stack to adhere to reactive components. We will use the reactive approach for this applicaiton in exposing REST endpoints, and our WS service as well.
You'll want to start a new Spring project using start.spring.io[this link] to autogenerate a maven based POM.  If you go with a different approach, just make sure to 
have `webflux`, and `lombok` projects.

We will use the `WebSocketHandlerAdapter` to handle our web socket handshake, upgrade, and other connection details.

.socket_handler_adapter
[source,java]
----
    @Bean
    WebSocketHandlerAdapter socketHandlerAdapter() {
        return new WebSocketHandlerAdapter();
    }
----

To get started, we will need a method for handling a websocket session. The simplest way to do this is to create a `WebSocketHandler` instance 
that calls `session.send` with our custom stream logic. For this handler, on each session we will stream 100 integers and append bang '!' for primes.
Using `Flux.interval` and `zipWith` in combination allows us to ensure a steady frequency of events.


.socket_session_handler
[source,java]
----
    WebSocketHandler webSocketHandler() {
        return session ->
                session.send(
                        Flux.interval(Duration.ofSeconds(1))
                                .zipWith(
                                        Flux.fromStream(Stream.iterate(0, i -> i + 1).limit(100))
                                        , (x, y) -> y + (is_prime(y) ? "!" : ""))
                                .map(session::textMessage))
                        .and(session.receive()
                                .map(WebSocketMessage::getPayloadAsText)
                                .doFinally(sig -> {
                                    log.info("session complete:" + sig.toString());
                                    session.close();
                                }));
    }
----

Using `and` operator lets us join this session with a `session.receive()` flow which reacts to incoming messages. In this case, we dont have any need



To route our URI's to a handler, we must 
== References/Readling List

* Spring WebFlux guide
** https://docs.spring.io/spring/docs/5.0.0.BUILD-SNAPSHOT/spring-framework-reference/html/web-reactive.html
** https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html

* Articles
** https://ordina-jworks.github.io/reactive/2016/12/12/Reactive-Programming-Spring-Reactor.html

* W3C Proposals
** https://tools.ietf.org/html/rfc6455

* Theory
** http://reactivex.io/documentation/operators.html
** https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/debounce.md


